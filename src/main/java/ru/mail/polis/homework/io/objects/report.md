### Результаты тестов при выборке в 750_000 объектов:
| Способ сериализации             | Размер файла (байт) | Время записи (мс) | Время чтения (мс) |
|---------------------------------|---------------------|-------------------|-------------------|
| `serializingWithExternalizable` | 101_410_936         | 35_363            | 36_573            |
| `customSerializing`             | 90_381_038          | 8_227             | 15_009            |
| `serializingWithMethods`        | 101_450_021         | 28_544            | 37_059            |
| `defaultSerializing`            | 96_238_464          | 19_223            | 55_191            |
- Можем заметить, что `customSerializing` использует наименьшее количество памяти для хранения данных,
а также наиболее эффективен для их записи и чтения. Неудивительно, ведь в кастомной сериализации мы
полностью берём на себя отвественность за написание и считывание данных, учитывая метаданные.
`defaultSerializing` достаточно гибкая, устроена таким образом, чтобы можно было сериализовать любой объект
(учитывая, что соблюдается необходимые требования (*Serializable*, *transient*)).
Чтобы поддерживать эту гибкость, универсальность, приходится жертвовать производительностью, так как в большинстве случаев
можно найти способ записать данные более оптимально и компактно (в нашем случае, например, в одном байте можно хранить
данные не только о *null* полях, но и о *boolean* полях).
- Также можно заметить, что `defaultSerializing` требует наибольшее количество времени для чтения данных.
Предполагаю, что это связано с тем, что используется *Reflection API* для присвоения считанных данных полям класса,
а это достаточно затратная операция по сравнению с обычным оператором присвоения, который используется в других
рассматриваемых способах сериализации. Однако по времени записи данных, этот способ сериализации идёт сразу после
`customSerializing`. Это объясняется тем, что *JVM* использует встроенные механизмы сериализации, которые во многом
реализованы с помощью ранее рассмотренного *Reflection API*, которые работают быстрее, чем кастинг объекта к
*Externalizable*, и последующий вызов необходимых функций в случае `serializingWithExternalizable`, и поиск необходимых
методов в случае `serializingWithMethods`, и их последующий вызов.
- Что касается памяти, наиболее затратными являются `serializingWithExternalizable` и `serializingWithMethods`
(сравнимы по количеству требуемой памяти, при разной выборке количество памяти с небольшой погрешностью относится 1 к 1).
Предполагаю, что это связано с метаданными, которые записываются `ObjectOutputStream` при вызове метода `writeObject`
с экземплярами классов, которые реализуют *Externalizable* или *Serizalizing* и содержат методы *readObject*
и *writeObject* с требуемой сигнатурой, чтобы записанные нами данные с помощью кастомных методов
(*writeExternal*, *writeObject*), могли быть считаны с помощью других кастомных методов (*readExternal* и *readObject*)
без проблем.