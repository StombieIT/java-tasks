### Результаты тестов при выборке в 750_000 объектов:
| Способ сериализации             | Размер файла (байт) | Время записи (мс) | Время чтения (мс) |
|---------------------------------|---------------------|-------------------|-------------------|
| `serializingWithExternalizable` | 101_409_498         | 29_496            | 36_112            |
| `customSerializing`             | 88_875_993          | 34_391            | 45_044            |
| `serializingWithMethods`        | 101_442_029         | 32_370            | 42_288            |
| `defaultSerializing`            | 96_138_928          | 20_465            | 50_743            |
- Можем заметить, что `customSerializing` использует наименьшее количество памяти для хранения данных. Неудивительно,
ведь в кастомной сериализации мы полностью берём на себя отвественность за написание и считывание данных, учитывая метаданные.
`defaultSerializing` достаточно гибкая, устроена таким образом, чтобы можно было сериализовать любой объект
(учитывая, что соблюдается необходимые требования (*Serializable*, *transient*)).
Чтобы поддерживать эту гибкость, универсальность, приходится жертвовать объёмом памяти записанных данных, так как в
большинстве случаев можно найти способ записать данные более компактно (в нашем случае, например, в одном байте можно хранить
данные не только о *null* полях, но и о *boolean* полях).

- Наиболее затратными по количеству памяти являются `serializingWithExternalizable` и `serializingWithMethods`
(сравнимы по количеству требуемой памяти, при разной выборке количество памяти с небольшой погрешностью относится 1 к 1).
Предполагаю, что это связано с метаданными, которые записываются `ObjectOutputStream` при вызове метода `writeObject`
с экземплярами классов, которые реализуют *Externalizable* или *Serizalizing* и содержат методы *readObject*
и *writeObject* с требуемой сигнатурой, чтобы записанные нами данные с помощью кастомных методов
(*writeExternal*, *writeObject*), могли быть считаны с помощью других кастомных методов (*readExternal* и *readObject*)
без проблем. Необходимость в хранении таких метаданных может быть связана с использованием `ObjectOutput` и `ObjectInput`
в соответствующих методах, ведь данные классы содержат небезопасные методы записи и чтения.
Это было особенно заметно, когда я использовал вместо *Data* аналогов *Object* стримы. Без вызова метода `flush` после
записанного логического куска информации список `Animal` из десериализованных объектов мог не досчитаться 1-5 объектами.
Метаданные как раз могут решать проблему небезопасных записи и чтения. Также стоит обратить внимание на то, что скорость
записи и чтения у `serializingWithExternalizable` немного быстрее, чем у `serializingWithMethods`. Это может быть связано
с использованием *Reflection API* в сериализации с методами, поиск и вызов подходящих методов через рефлексию может быть
более затратным.

- Также в глаза бросается наибольшее время записи и чтения данных у `customSerializing`,
не учитывая время чтения `defaultSerializing` (далее поясняется, почему у дефолтной сериализации чтение данных сильно
больше, чем у других способов сериализации). Это связано с тем, что вместо *Object* стримов используются *Data*,
которые содержат более безопасные методы для записи и чтения, что хуже сказывается на производительности, однако
позволяет задействовать меньше памяти для хранения данных.

- Также можно заметить, что `defaultSerializing` требует наибольшее количество времени для чтения данных.
Предполагаю, что это связано с тем, что используется *Reflection API* для присвоения считанных данных полям класса,
а это достаточно затратная операция по сравнению с обычным оператором присвоения, который используется в других
рассматриваемых способах сериализации. Однако по времени записи данных, этот способ сериализации идёт первым. Это
объясняется тем, что *JVM* использует встроенные механизмы сериализации, которые во многом реализованы с помощью ранее
рассмотренного *Reflection API*, которые работают быстрее, чем `writeObject` у `ObjectOutput`, внутри которого
происходит кастинг объекта к *Externalizable*, и последующий вызов необходимых функций в случае `serializingWithExternalizable`,
и поиск необходимых методов в случае `serializingWithMethods`, и их последующий вызов.